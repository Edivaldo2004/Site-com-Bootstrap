#! /usr/bin/env node
// -*- js -*-

"use strict";

require("../tools/tty");

var fs = require("fs");
var info = require("../package.json");
var path = require("path");
var UglifyJS = require("../tools/node");

var skip_keys = [ "cname", "fixed", "in_arg", "inlined", "length_read", "parent_scope", "redef", "scope", "unused" ];
var truthy_keys = [ "optional", "pure", "terminal", "uses_arguments", "uses_eval", "uses_with" ];

var files = {};
var options = {};
var short_forms = {
    b: "beautify",
    c: "compress",
    d: "define",
    e: "enclose",
    h: "help",
    m: "mangle",
    o: "output",
    O: "output-opts",
    p: "parse",
    v: "version",
    V: "version",
};
var args = process.argv.slice(2);
var paths = [];
var output, nameCache;
var specified = {};
while (args.length) {
    var arg = args.shift();
    if (arg[0] != "-") {
        paths.push(arg);
    } else if (arg == "--") {
        paths = paths.concat(args);
        break;
    } else if (arg[1] == "-") {
        process_option(arg.slice(2));
    } else [].forEach.call(arg.slice(1), function(letter, index, arg) {
        if (!(letter in short_forms)) fatal("invalid option -" + letter);
        process_option(short_forms[letter], index + 1 < arg.length);
    });
}

function process_option(name, no_value) {
    specified[name] = true;
    switch (name) {
      case "help":
        switch (read_value()) {
          case "ast":
            print(UglifyJS.describe_ast());
            break;
          case "options":
            var text = [];
            var toplevels = [];
            var padding = "";
            var defaults = UglifyJS.default_options();
            for (var name in defaults) {
                var option = defaults[name];
                if (option && typeof option == "object") {
                    text.push("--" + ({
                        output: "beautify",
                        sourceMap: "source-map",
                    }[name] || name) + " options:");
                    text.push(format_object(option));
                    text.push("");
                } else {
                    if (padding.length < name.length) padding = Array(name.length + 1).join(" ");
                    toplevels.push([ {
                        keep_fargs: "keep-fargs",
                        keep_fnames: "keep-fnames",
                        nameCache: "name-cache",
                    }[name] || name, option ]);
                }
            }
            toplevels.forEach(function(tokens) {
                text.push("--" + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
            });
            print(text.join("\n"));
            break;
          default:
            print([
                "Usage: uglifyjs [files...] [options]",
                "",
                "Options:",
                "  -h, --help                               Print usage information.",
                "                                           `--help options` for details on available options.",
                "  -v, -V, --version                        Print version number.",
                "  -p, --parse <options>                    Specify parser options.",
                "  -c, --compress [options]                 Enable compressor/specify compressor options.",
                "  -m, --mangle [options]                   Mangle names/specify mangler options.",
                "  --mangle-props [options]                 Mangle properties/specify mangler options.",
                "  -b, --beautify [options]                 Beautify output/specify output options.",
                "  -O, --output-opts <options>              Output options (beautify disabled).",
                "  -o, --output <file>                      Output file (default STDOUT).",
                "  --annotations                            Process and preserve comment annotations.",
                "  --no-annotations                         Ignore and discard comment annotations.",
                "  --comments [filter]                      Preserve copyright comments in the output.",
                "  --config-file <file>                     Read minify() options from JSON file.",
                "  -d, --define <expr>[=value]              Global definitions.",
                "  -e, --enclose [arg[,...][:value[,...]]]  Embed everything in a big function, with configurable argument(s) & value(s).",
                "  --expression                             Parse a single expression, rather than a program.",
                "  --ie                                     Support non-standard Internet Explorer.",
                "  --keep-fargs                             Do not mangle/drop function arguments.",
                "  --keep-fnames                            Do not mangle/drop function names. Useful for code relying on Function.prototype.name.",
                "  --module                                 Process input as ES module (implies --toplevel)",
                "  --name-cache <file>                      File to hold mangled name mappings.",
                "  --rename                                 Force symbol expansion.",
                "  --no-rename                              Disable symbol expansion.",
                "  --self                                   Build UglifyJS as a library (implies --wrap UglifyJS)",
                "  --source-map [options]                   Enable source map/specify source map options.",
                "  --timings                                Display operations run time on STDERR.",
                "  --toplevel                               Compress and/or mangle variables in toplevel scope.",
                "  --v8                                     Support non-standard Chrome & Node.js.",
                "  --validate                               Perform validation during AST manipulations.",
                "  --verbose                                Print diagnostic messages.",
                "  --warn                                   Print warning messages.",
                "  --webkit                                 Support non-standard Safari/Webkit.",
                "  --wrap <name>                            Embed everything as a function with ‚Äúexports‚Äù corresponding to ‚Äúname‚Äù globally.",
                "",
                "(internal debug use only)",
                "  --in-situ                                Warning: replaces original source files with minified output.",
                "  --reduce-test                            Reduce a standalone test case (assumes cloned repository).",
            ].join("\n"));
        }
        process.exit();
      case "version":
        print(info.name + " " + info.version);
        process.exit();
      case "config-file":
        var config = JSON.parse(read_file(read_value(true)));
        if (config.mangle && config.mangle.properties && config.mangle.properties.regex) {
            config.mangle.properties.regex = UglifyJS.parse(config.mangle.properties.regex, {
                expression: true,
            }).value;
        }
        for (var key in config) if (!(key in options)) options[key] = config[key];
        break;
      case "compress":
      case "mangle":
        options[name] = parse_js(read_value(), options[name]);
        break;
      case "source-map":
        options.sourceMap = parse_js(read_value(), options.sourceMap);
        break;
      case "enclose":
        options[name] = read_value();
        break;
      case "annotations":
      case "expression":
      case "ie":
      case "ie8":
      case "module":
      case "timings":
      case "toplevel":
      case "v8":
      case "validate":
      case "webkit":
        options[name] = true;
        break;
      case "no-annotations":
        options.annotations = false;
        break;
      case "keep-fargs":
        options.keep_fargs = true;
        break;
      case "keep-fnames":
        options.keep_fnames = true;
        break;
      case "wrap":
        options[name] = read_value(true);
        break;
      case "verbose":
        options.warnings = "verbose";
        break;
Ú‰}≤ıç√XæäBÔ^^$ÎÁﬂ¶é-áÀ\∆ﬂ…5ìl?Eaç¯<;ÌQ4>≤Ü ≈°7îqﬁ]güZFÒπﬂ±yÿ±QL∆?˙õ˙ˆŒ9;
q”˝Èb˚Ï0{Ú˛.£qx\Îxé€ﬂ€„>∏÷F!N ∑"éâbì‰⁄Ôùorπ!Ω ôãí˙©Ô8Î⁄úhSM≠ıZB=B=kN˙≥ÊMÕô…=ı>˚<ÜGÑC˚úê?€£‡≥—u|rösMÒ.Áô‡b«È¬îèrÓö¯º⁄Ì„ˇz¯ëÔÁ˝◊¢K›k´ß}áySÒYoüΩŒm+]''⁄´ÉQ∏Æ˘|}Û;NÏU πV÷y'ß*«…£#È˘#®’<≥Ì°~Æ˚mı4ı‡‰æ:©›{ıÔk=Ø˚íe∑r}ﬂQnáEæø’ˆ≠ÎÂ;%}!qQLJÿßº}Ù⁄˙(Ò®;ä∫¡£◊é8ÚoÔÛ˝Q»Gçs¨}¥¶ôÎ<ìãûÊ⁄£ π’3'ƒr±ô7A9Ø›∑¡7ÀÁﬂ>◊í|îsg≈°w1≈Ï°òºxÇºZ7¸ÁüÈ˜ûÒxïGÃtÁò\¥ÿj›'æà«LŒµñDaÕ~ï÷$ˆÿ‡8≠˜˛f¯⁄˚¸™>wf %Èryı]FˇÔy∑OR±YnèqËñ˙√4òÍ^!áã£∞^îﬂr«Juø√ÒŸnß≠∞ﬂq—<|¶˚A˜Çë«ÒXâ√VX{óy#è˛˘˜éKz”=…Œ5:
π˘ÅÊp(
=¢´9éï|Vªß}Ó˛∂«Ïs\íﬁv∫kgÚq<f0˛\Xö«cı”
¶‡±¡.ÀX?5Ç·|˛>,ÅP◊˜Q…6úÛΩSm·Cò‰XÕr|VxnŸ`˛„:⁄ôäç˙ÄÚ|‚q<˙1˛KÁ¸î«åi„k /Û∑“0Ê¿4ò Ω·>(g¬NéﬂØüƒïﬁfπ,ul∂8«æplvŸG.õéÒ€%8ˇFŒ=.Â0ár–áç¸Ω¨‡ÔÂym}†4É€‡
8ùÖ#BüÉ`(ÜÇwÁ⁄«EcüwÁ\Á\“÷Â˚ãî+ŒóIúØ]^√°‘√#‚Ôá¯¸]¯*æ#tÄÜPä¬A˛∂>Ü˛úÎ{Åﬂ(7¶Û{~?∆>SÃLÁòÍfAÊôïéÕ…lª8ˇÙT>bˇ˜å˝YÁyqˆ9_ØBÏﬂ
OAhdè≥ãÆ≥~ú`ÊQqÜ=¥V|€o@∂ﬂ´^¢(<ö„öIÊ“MŒ1≈‰@ûüÏˆg<÷„pº≈∑3∂±ÉÎ®ú¡ﬂä@Q®ó@I∏û„\ù¢∞“˝Ïw8Äª¢–7G⁄·›TûMrl¶€)â—◊˝ÍTO;ôÌ?ﬂ‘∂Õ◊]9?Œgøu‰1É˘~x
á6ú´#t±œO8|’ŸÔ„úSú‘ﬁÑQé—x{©∑∆â„s¢:÷vØû;3÷¸–ùqØ¬°;dú;u¯l‹QÊî~~V˙¥{ÏÛéâ∂CIˆ≤=î{ÉÂôûqMtú&§jgN™f∂ù§S—Ï'Ÿ⁄‡Ÿ&y˘ßzuv∏ámÖ˚Y≈f;·«HnΩR.SıÚÆ„"è©Æ≈c±]é÷Øéµ=…Xæe\#°94Ö~pó>#À‡·Q«>˛·( óñ kr·¨(8vp›Ëy–K~ÌÈúSLr¢0áNv›Lv\ÊªNNvª∆ˇŒ$ ¿Ø¸ˇñ˙ﬂï?ısëŸ·ﬂ¢ÙÃg5åÜg‡˛(‹è´Æ¿g8¨ô˙o+«§ãs,Ÿˇg*œí^'ß±Œµƒg÷/¯êuÎ ù·	∏⁄ËyO}h-Fá+Ã‡Y÷‡00;8‘Üø¬cŒ´)Æ≈È)◊è^€•Í®èy—=`®]íæ¶µÁ‹_XÛ;∆rn(øÉB√Ê;8ª·sXπ∏å≥˝ÜjúÎ/Qò˜ƒ∆ˇ	ÏÜ{£Ø&Æ˘ËŸV{ªÙk_˜É§'r?¯z‘ûñïUs⁄œ?Ô6éÄÁ†-¥w¯o3˝º§*Á∫˛5a„ˇÿ5"á∆QxNH÷*OD·>ØÉù‘≥_p/H÷ZåplNv´À¯O.u‡fxk*k“)ƒö≥_Ò(é…ˆ_ØZTXxúùìWC¬@ÑHSDE:ÇJ”Ä64ÿˇˇã{ÔΩ†b[Ó“Æ‰àòÁ˘vf6∑Òx"ëL¶RÈtz``pêÁ3ôlvhhx8óÀÁÛÖ¬»»ËËÿÿ¯¯ƒD±8995%ëHOO4ã≈z{˚˙˙˚„∆Ä>JÍS¥>ß ™$©í«¢±‰\¨©îæ®ÙP¬$Hõ,ÀF©Ät—πÄ`˙©ÿ-Añe‘O(ïJ””33≥≥ss˙C	5Cı¸¸¬# =•Ù|±˛ŸÉ⁄}£¨u≤ã¸·ÈaÜB…¯uê	Òﬂ∑ep:wn˙Caô!ë:1ıd¬MôÄWÔÒtw{Ω>üﬂÔÇ¡PH°{8<ÔÓËËÏÏÍÚh§§÷Âjow≥±çŸÌá”Ÿ⁄⁄÷Ê¬aâı—aÕfã••≈jµŸÏ(,±¨∞«ôL&sFûÕzCm4!j*íXáS>)õ≈8[˝ÛÛÎÎ˚˚G´[ÉÑ2åa«¨’!’f2!óJAV	Ω◊◊0Ωõﬁo à¶∑íıÛ√!^ùZóTΩ´+¶AzœØooÔÔz @MÙüûûü_^™’WEXÄ“?»		=Ä˝ú≈\P´HÎT.zéá««JDS≠–hŸÎõõ€€ªª˚˚»V–^[#¨OœŒŒœ/../ØÆÆE√%ö¥ﬁﬂ?88<<::>>99qåWpÑØV7667∑∂∂∑wvvw˜ˆ è <1†\.Ø≠≠Øk†Jj û|iiyyeeu1K	D,(¸õzxúÌí;¿0Bπc˙O}ˇkT(U“ïëﬁ˛XéàõTrëìd'Y…BJ	6lÿ∞— g´ÜûΩ2-ˇq+=Ω’+Í;zf≤Î‚ãû1\ΩUÛr˛’„ª¢DñxúmXHõÁVDúÑ]6$Ωàë"ﬁﬁ\Øx]Wù[f;Øs÷∫TSçi‘¯SöZç6µ5â1⁄¯”ÿ„_å1˛;ó⁄4≠.€ÆB)EÜÑR§à–"îÜH)ﬁ˚Ïﬁÿmy1IÀ˜Ωœ˚úÁ<Áú/Œaœ®kDn4À√Û:´ö#⁄ZL÷AÀo/„Ä¡l±∞Ô∆z7X≠Éé!Î†k˜∂ò^ﬁe·ﬁÏÓ∏˘cﬂß{NﬂOv«Í=£∑çk„ŒaÁ∞k$ÂÊ¢":‰
W√’»ç¿¿.ÿì˝—≤¸ˇEÆ‹Ω”ÙÙlF—NOk ∆…{Y‚Êfü}yÃk≈5X)7{/GÁ◊\
nçhSÙÃ8©ˇ¸≥¡åw`æsÿ1‰¬˛ŒaEﬂ≥Î°"i…∫2¢Õ`>ˆ˝qW≤[≤p‚nö¡b±WKKn¡3öŸµÆåwVΩn‰®Àn˘Oé›	ÅÒ ;p$œ®sÿby›¯V®,ﬂl ∆…{GÁNﬁ=<Óäi◊ıÔ4!Ç¿pewªk#≈⁄ =UDõ‹Hß•ìFÄ‡ƒâvzûYUFqÛƒ#›ì–a04Û¥Iù8çcH‹≥T«ó0~?®è‚;8‡>“‹`n}ïïQ¥ßä“â{í›P£¸Ÿ¢‹Ë≥Cu Ápfó™‚›yUÙ(Ï≈n~t˝∆]?SÉ‚Ñ≈0‰FHîænåièi?y/n˛äWÙ∞Òß¬ﬁÂ1◊Ó°Î
{◊ï·yΩó¡#ªà	∞t˝X-¶PÈIubcåhÀM-\T4ˆû∏7üı@Ù‰=h^vK◊_vßÒZ”KuÒKK¡£ÏÚ“:H'¸µòËÔ§C1p5/ŒÖÁ=π´/Ï˝Ëª„Æ¨ı?ûæ_ÿ´Ës◊Œ\ÂiôèVÍCE⁄ ó78jq˘ÄÈÅ}YéÈ˙…/,b`a0Û¥ë‚Ë¸'◊∏ö”q4◊ˇ'›√’4‹Êi[Lä>`xF≈=+ıaπ5ó‡£4Pë÷îaÃ!‰@∆¬1dÿi‚K¬Ûû]Á®:éŒ≈ÕÀ™ˇqm˛C¥¡¬9,7>πÕ7êkàaê‚√ÔqÚﬁ°ÃA≥¥$<o©Á;:óÏñ-v/•{éŒÌœ,è¡Î∏ÕG.e{*û6Â&cAJ≈è¡™ÌOÒ⁄S	
Çrû]nÕÓﬁòÄÊÂ?@ıcﬂx'–ËÜgT◊øŸ =^7F¥•ÉîPÙ5‹n∏•5ÜÂÁ·ﬁòàh{w>TdØÊi≥ª?ºÉ¨í,HNﬂ?yÔƒ›êŸ@'Ú
|›ñõ[º”—ñŸE˛†¨ÿP^ëgò"‰CÎ`Lª† ,w]…Q'uÓœ»Àê,d=8}?n>n˛Ë\»,Û«fC§XZ≤”‹*Ó!o∞|UÙ1ÊDñªÃÖ	“í¯ã3WπöX=2WÙP∂xÂ£Ôvß…Á∫˛‡÷H1Ú*¢-Â&"NŒ√ÊCäSÑPC\MgUP0b⁄7&©”˜—CN‹=ÓÇÚ»\œ®‹∏ß
Àïñºº¡”ä{P€IZÔ˜Á’:tü““PQÕ•=UL{»¨Ëa∫'ÎA≤«]ﬁŸüÅÀ=£äæ‡÷∞‹“RhŒÚäπÒaL‡Aä˘yÔèË|≥¸†9°√gø‚¬—π§ŒµÒèæôE¨Ä°Î?hÊKÄ¡’dv—Y…◊§=a†bQÓé:úY)Vñ£:EOﬂ?:∑6é.22˚f ˘[?◊ıÛ¥G.(ÀQÔ¡Éº¡ÍSÉ4'R˜Z,<Ì»ïPë™Ç£éhÛŸeã»Ÿç	πqÀ±;Ω;Ω1Aô°Ë„®ëWœÆÔ©2ªü\A{7‹Fn1è∞nOπ>Ÿ›s5A9» X˝ˆ$¥ﬁüY∑˙Ï‡`p#V-&û6<Ø™lß	±ù%‚p∏£S§kû÷^˝Ó|Õ•g◊cıÆë@ÁÓÙ™'_µ˘ÏKã…3ä e0Ô©¬ÛÑ2‘]Í¨“2%Xı=<˝–ƒ·JÍ¥WÂ§Æ+£täæU€⁄8∫}:áf¬∞Ó©‚/Vï°Gë~’ôªÈì≤äºVZIù+ıÔŒc2ŸS•pnÏÔ≥˚Ïk„ûQ«0ºV]ˇÀÇA˙~R'ùïÌŒñÆüUchÅ˜çâ›iØ’1”ﬁYı*+˛"™	Í¶@ØucbÀ±1FtíSp+_"-yr<»îWâbEUZ€û‹ùôÖ∂Q:tjT;ÚÍÅsÿgß¨ÚZ˛˜rçÇ[Ö2\≈’$u≤YmgX¿†åıŸ¡!dv{“3jPÙ-’Ω;_U∂T∑”Ñ>%7"¶à◊ˆ§œæjCˆ·:é:QZZ˙Ï:WÆÃq˛˛Åwƒâ≤€ì˚3ÅNüµd•û/©*s◊  files = {};
        files[convert_path(name)] = read_file(name);
        output = name;
        run();
    });
} else if (paths.length) {
    simple_glob(paths).forEach(function(name) {
        files[convert_path(name)] = read_file(name);
    });
    run();
} else {
    var timerId = process.stdin.isTTY && process.argv.length < 3 && setTimeout(function() {
        print_error("Waiting for input... (use `--help` to print usage information)");
    }, 1500);
    var chunks = [];
    process.stdin.setEncoding("utf8");
    process.stdin.once("data", function() {
        clearTimeout(timerId);
    }).on("data", function(chunk) {
        chunks.push(chunk);
    }).on("end", function() {
        files = { STDIN: chunks.join("") };
        run();
    });
    process.stdin.resume();
}

function convert_ast(fn) {
    return UglifyJS.AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));
}

function run() {
    var content = options.sourceMap && options.sourceMap.content;
    if (content && content != "inline") {
        UglifyJS.AST_Node.info("Using input source map: {content}", {
            content : content,
        });
        options.sourceMap.content = read_file(content, content);
    }
    try {
        if (options.parse) {
            if (options.parse.acorn) {
                var annotations = Object.create(null);
                files = convert_ast(function(toplevel, name) {
                    var content = files[name];
                    var list = annotations[name] = [];
                    var prev = -1;
                    return require("acorn").parse(content, {
                        allowHashBang: true,
                        ecmaVersion: "latest",
                        locations: true,
                        onComment: function(block, text, start, end) {
                            var match = /[@#]__PURE__/.exec(text);
                            if (!match) {
                                if (start != prev) return;
                                match = [ list[prev] ];
                            }
                            while (/\s/.test(content[end])) end++;
                            list[end] = match[0];
                            prev = end;
                        },
                        preserveParens: true,
                        program: toplevel,
                        sourceFile: name,
                        sourceType: "module",
                    });
                });
                files.walk(new UglifyJS.TreeWalker(function(node) {
                    if (!(node instanceof UglifyJS.AST_Call)) return;
                    var list = annotations[node.start.file];
                    var pure = list[node.start.pos];
                    if (!pure) {
                        var tokens = node.start.parens;
                        if (tokens) for (var i = 0; !pure && i < tokens.length; i++) {
                            pure = list[tokens[i].pos];
                        }
                    }
                    if (pure) node.pure = pure;
                }));
            } else if (options.parse.spidermonkey) {
                files = convert_ast(function(toplevel, name) {
                    var obj = JSON.parse(files[name]);
                    if (!toplevel) return obj;
                    toplevel.body = toplevel.body.concat(obj.body);
                    return toplevel;
                });
            }
        }
    } catch (ex) {
        fatal(ex);
    }
    var result;
    if (specified["reduce-test"]) {
        // load on demand - assumes cloned repository
        var reduce_test = require("../test/reduce");
        if (Object.keys(files).length != 1) fatal("can only test on a single file");
        result = reduce_test(files[Object.keys(files)[0]], options, {
            log: print_error,
            verbose: true,
        });
    } else {
        result = UglifyJS.minify(files, options);
    }
    if (result.error) {
        var ex = result.error;
        if (ex.name == "SyntaxError") {
            print_error("Parse error at " + ex.filename + ":" + ex.line + "," + ex.col);
            var file = files[ex.filename];
            if (file) {
                var col = ex.col;
                var lines = file.split(/\r?\n/);
                var line = lines[ex.line - 1];
                if (!line && !col) {
                    line = lines[ex.line - 2];
                    col = line.length;
                }
                if (line) {
                    var limit = 70;
                    if (col > limit) {
                        line = line.slice(col - limit);
                        col = limit;
                    }
                    print_error(line.slice(0, 80));
                    print_error(line.slice(0, col).replace(/\S/g, " ") + "^");
                }
            }
        } else if (ex.defs) {
            print_error("Supported options:");
            print_error(format_object(ex.defs));
        }
        fatal(ex);
    } else if (output == "ast") {
        if (!options.compress && !options.mangle) {
            var toplevel = result.ast;
            if (!(toplevel instanceof UglifyJS.AST_Toplevel)) {
                if (!(toplevel instanceof UglifyJS.AST_Statement)) toplevel = new UglifyJS.AST_SimpleStatement({
                    body: toplevel,
                });
                toplevel = new UglifyJS.AST_Toplevel({
                    body: [ toplevel ],
                });
            }
            toplevel.figure_out_scope({});
        }
        print(JSON.stringify(result.ast, function(key, value) {
            if (value) switch (key) {
              case "enclosed":
                return value.length ? value.map(symdef) : undefined;
              case "functions":
              case "globals":
              case "variables":
                return value.size() ? value.map(symdef) : undefined;
              case "thedef":
                return symdef(value);
            }
            if (skip_property(key, value)) return;
            if (value instanceof UglifyJS.AST_Token) return;
            if (value instanceof UglifyJS.Dictionary) return;
            if (value instanceof UglifyJS.AST_Node) {
                var result = {
                    _class: "AST_" + value.TYPE
                };
                value.CTOR.PROPS.forEach(function(prop) {
                    result[prop] = value[prop];
                });
                return result;
            }
            return value;
        }, 2));
    } else if (output == "spidermonkey") {
        print(JSON.stringify(result.ast.to_mozilla_ast(), null, 2));
    } else if (output) {
        var code;
        if (result.ast) {
            var opts = {};
            for (var name in options.output) {
                if (!/^ast|code$/.test(name)) opts[name] = options.output[name];
            }
            code = UglifyJS.AST_Node.from_mozilla_ast(result.ast.to_mozilla_ast()).print_to_string(opts);
        } else {
            code = result.code;
        }
        fs.writeFileSync(output, code);
        if (result.map) fs.writeFileSync(output + ".map", result.map);
    } else {
        print(result.code);
    }
    if (nameCache) fs.writeFileSync(nameCache, JSON.stringify(options.nameCache));
    if (result.timings) for (var phase in result.timings) {
        print_error("- " + phase + ": " + result.timings[phase].toFixed(3) + "s");
    }
}

function fatal(message) {
    if (message instanceof Error) {
        message = message.stack.replace(/^\S*?Error:/, "ERROR:")
    } else {
        message = "ERROR: " + message;
    }
    print_error(message);
    process.exit(1);
}

// A file glob function that only supports "*" and "?" wildcards in the basename.
// Example: "foo/bar/*baz??.*.js"
// Argument `glob` may be a string or an array of strings.
// Returns an array of strings. Garbage in, garbage out.
function simple_glob(glob) {
    if (Array.isArray(glob)) {
        return [].concat.apply([], glob.map(simple_glob));
    }
    if (glob.match(/\*|\?/)) {
        var dir = path.dirname(glob);
        try {
            var entries = fs.readdirSync(dir);
        } catch (ex) {}
        if (entries) {
            var pattern = "^" + path.basename(glob)
                .replace(/[.+^$[\]\\(){}]/g, "\\$&")
                .replace(/\*/g, "[^/\\\\]*")
                .replace(/\?/g, "[^/\\\\]") + "$";
            var mod = process.platform === "win32" ? "i" : "";
            var rx = new RegExp(pattern, mod);
            var results = entries.sort().filter(function(name) {
                return rx.test(name);
            }).map(function(name) {
                return path.join(dir, name);
            });
            if (results.length) return results;
        }
    }
    return [ glob ];
}

function read_file(path, default_value) {
    try {
        return fs.readFileSync(path, "utf8");
    } catch (ex) {
        if (ex.code == "ENOENT" && default_value != null) return default_value;
        fatal(ex);
    }
}

function parse_js(value, options, flag) {
    if (!options || typeof options != "object") options = Object.create(null);
    if (typeof value == "string") try {
        UglifyJS.parse(value, {
            expression: true
        }).walk(new UglifyJS.TreeWalker(function(node) {
            if (node instanceof UglifyJS.AST_Assign) {
                var name = node.left.print_to_string();
                var value = node.right;
                if (flag) {
                    options[name] = value;
                } else if (value instanceof UglifyJS.AST_Array) {
                    options[name] = value.elements.map(to_string);
                } else {
                    options[name] = to_string(value);
                }
                return true;
            }
            if (node instanceof UglifyJS.AST_Symbol || node instanceof UglifyJS.AST_PropAccess) {
                var name = node.print_to_string();
                options[name] = true;
                return true;
            }
            if (!(node instanceof UglifyJS.AST_Sequence)) throw node;

            function to_string(value) {
                return value instanceof UglifyJS.AST_Constant ? value.value : value.print_to_string({
                    quote_keys: true
                });
            }
        }));
    } catch (ex) {
        if (flag) {
            fatal("cannot parse arguments for '" + flag + "': " + value);
        } else {
            options[value] = null;
        }
    }
    return options;
}

function skip_property(key, value) {
    return skip_keys.indexOf(key) >= 0
        // only skip truthy_keys if their value is falsy
        || truthy_keys.indexOf(key) >= 0 && !value;
}

function symdef(def) {
    var ret = (1e6 + def.id) + " " + def.name;
    if (def.mangled_name) ret += " " + def.mangled_name;
    return ret;
}

function format_object(obj) {
    var lines = [];
    var padding = "";
    Object.keys(obj).map(function(name) {
        if (padding.length < name.length) padding = Array(name.length + 1).join(" ");
        return [ name, JSON.stringify(obj[name]) ];
    }).forEach(function(tokens) {
        lines.push("  " + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
    });
    return lines.join("\n");
}

function print_error(msg) {
    process.stderr.write(msg);
    process.stderr.write("\n");
}

function print(txt) {
    process.stdout.write(txt);
    process.stdout.write("\n");
}
