#! /usr/bin/env node
// -*- js -*-

"use strict";

require("../tools/tty");

var fs = require("fs");
var info = require("../package.json");
var path = require("path");
var UglifyJS = require("../tools/node");

var skip_keys = [ "cname", "fixed", "in_arg", "inlined", "length_read", "parent_scope", "redef", "scope", "unused" ];
var truthy_keys = [ "optional", "pure", "terminal", "uses_arguments", "uses_eval", "uses_with" ];

var files = {};
var options = {};
var short_forms = {
    b: "beautify",
    c: "compress",
    d: "define",
    e: "enclose",
    h: "help",
    m: "mangle",
    o: "output",
    O: "output-opts",
    p: "parse",
    v: "version",
    V: "version",
};
var args = process.argv.slice(2);
var paths = [];
var output, nameCache;
var specified = {};
while (args.length) {
    var arg = args.shift();
    if (arg[0] != "-") {
        paths.push(arg);
    } else if (arg == "--") {
        paths = paths.concat(args);
        break;
    } else if (arg[1] == "-") {
        process_option(arg.slice(2));
    } else [].forEach.call(arg.slice(1), function(letter, index, arg) {
        if (!(letter in short_forms)) fatal("invalid option -" + letter);
        process_option(short_forms[letter], index + 1 < arg.length);
    });
}

function process_option(name, no_value) {
    specified[name] = true;
    switch (name) {
      case "help":
        switch (read_value()) {
          case "ast":
            print(UglifyJS.describe_ast());
            break;
          case "options":
            var text = [];
            var toplevels = [];
            var padding = "";
            var defaults = UglifyJS.default_options();
            for (var name in defaults) {
                var option = defaults[name];
                if (option && typeof option == "object") {
                    text.push("--" + ({
                        output: "beautify",
                        sourceMap: "source-map",
                    }[name] || name) + " options:");
                    text.push(format_object(option));
                    text.push("");
                } else {
                    if (padding.length < name.length) padding = Array(name.length + 1).join(" ");
                    toplevels.push([ {
                        keep_fargs: "keep-fargs",
                        keep_fnames: "keep-fnames",
                        nameCache: "name-cache",
                    }[name] || name, option ]);
                }
            }
            toplevels.forEach(function(tokens) {
                text.push("--" + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
            });
            print(text.join("\n"));
            break;
          default:
            print([
                "Usage: uglifyjs [files...] [options]",
                "",
                "Options:",
                "  -h, --help                               Print usage information.",
                "                                           `--help options` for details on available options.",
                "  -v, -V, --version                        Print version number.",
                "  -p, --parse <options>                    Specify parser options.",
                "  -c, --compress [options]                 Enable compressor/specify compressor options.",
                "  -m, --mangle [options]                   Mangle names/specify mangler options.",
                "  --mangle-props [options]                 Mangle properties/specify mangler options.",
                "  -b, --beautify [options]                 Beautify output/specify output options.",
                "  -O, --output-opts <options>              Output options (beautify disabled).",
                "  -o, --output <file>                      Output file (default STDOUT).",
                "  --annotations                            Process and preserve comment annotations.",
                "  --no-annotations                         Ignore and discard comment annotations.",
                "  --comments [filter]                      Preserve copyright comments in the output.",
                "  --config-file <file>                     Read minify() options from JSON file.",
                "  -d, --define <expr>[=value]              Global definitions.",
                "  -e, --enclose [arg[,...][:value[,...]]]  Embed everything in a big function, with configurable argument(s) & value(s).",
                "  --expression                             Parse a single expression, rather than a program.",
                "  --ie                                     Support non-standard Internet Explorer.",
                "  --keep-fargs                             Do not mangle/drop function arguments.",
                "  --keep-fnames                            Do not mangle/drop function names. Useful for code relying on Function.prototype.name.",
                "  --module                                 Process input as ES module (implies --toplevel)",
                "  --name-cache <file>                      File to hold mangled name mappings.",
                "  --rename                                 Force symbol expansion.",
                "  --no-rename                              Disable symbol expansion.",
                "  --self                                   Build UglifyJS as a library (implies --wrap UglifyJS)",
                "  --source-map [options]                   Enable source map/specify source map options.",
                "  --timings                                Display operations run time on STDERR.",
                "  --toplevel                               Compress and/or mangle variables in toplevel scope.",
                "  --v8                                     Support non-standard Chrome & Node.js.",
                "  --validate                               Perform validation during AST manipulations.",
                "  --verbose                                Print diagnostic messages.",
                "  --warn                                   Print warning messages.",
                "  --webkit                                 Support non-standard Safari/Webkit.",
                "  --wrap <name>                            Embed everything as a function with â€œexportsâ€ corresponding to â€œnameâ€ globally.",
                "",
                "(internal debug use only)",
                "  --in-situ                                Warning: replaces original source files with minified output.",
                "  --reduce-test                            Reduce a standalone test case (assumes cloned repository).",
            ].join("\n"));
        }
        process.exit();
      case "version":
        print(info.name + " " + info.version);
        process.exit();
      case "config-file":
        var config = JSON.parse(read_file(read_value(true)));
        if (config.mangle && config.mangle.properties && config.mangle.properties.regex) {
            config.mangle.properties.regex = UglifyJS.parse(config.mangle.properties.regex, {
                expression: true,
            }).value;
        }
        for (var key in config) if (!(key in options)) options[key] = config[key];
        break;
      case "compress":
      case "mangle":
        options[name] = parse_js(read_value(), options[name]);
        break;
      case "source-map":
        options.sourceMap = parse_js(read_value(), options.sourceMap);
        break;
      case "enclose":
        options[name] = read_value();
        break;
      case "annotations":
      case "expression":
      case "ie":
      case "ie8":
      case "module":
      case "timings":
      case "toplevel":
      case "v8":
      case "validate":
      case "webkit":
        options[name] = true;
        break;
      case "no-annotations":
        options.annotations = false;
        break;
      case "keep-fargs":
        options.keep_fargs = true;
        break;
      case "keep-fnames":
        options.keep_fnames = true;
        break;
      case "wrap":
        options[name] = read_value(true);
        break;
      case "verbose":
        options.warnings = "verbose";
        break;
òä}²õÃX¾ŠBï^^$ëçß¦-‡Ë\ÆßÉ5“l?Eaø<;íQ4>²†ÊÅ¡7”qŞ]gŸZFñ¹ß±yØ±QLÆ?ú›úöÎ9;
qÓıébûì0{òş.£qx\ëxÛßÛã>¸ÖF!NÊ·"‰b“äÚïor¹!½ ™‹’ú©ï8ëÚœhSM­õZB=B=kNú³æMÍ™É=õ>û<†G„Cûœ?Û£à³Ñu|ršsMñ.ç™àbÇéÂ”rîšøğ¼Úíãÿzø‘ïçğı×¢Kİk«§}‡ySñYoŸ½Îm+]''Ú«ƒQ¸®ù|}ó;NìUÊ¹VÖy'§*ÇÉ£#éù#¨Õ<³í¡~®ûmõ4õàä¾:©İ{õïk=¯û’e·r}ßQn‡E¾¿Õö­ëå;%}!qQLJØ§¼}ôÚú(ñ¨;ŠºÁ£×8òoïóıQÈGs¬}´¦™ë<“‹æÚ£ ¹Õ3'Är±™7A9¯İ·Á7Ëçß>×’|”sgÅ¡w1Åì¡˜¼x‚¼Z7üçŸé÷ñx•GÌtç˜\´Øjİ'¾ˆÇLÎµ–DaÍ~•Ö$öØà8­÷şføÚûüª>wfÊ%éryõ]Fÿïy·OR±Ynqè–úÃ4˜ê^!‡‹£°^”ßrÇJu¿ÃñÙn§­°ßqÑ<|¦ûA÷‚‘ÇñX‰ÃVX{—y#şù÷KzÓ=ÉÎ5:
¹ùæp(
=¢«9•|V»§}îş¶Çìs\’Şvºkgòq<f0ş\XšÇcõÓ
¦à±Á.ËX?5‚á|ş>,P×÷QÉ6œó½SmáC˜äXÍr|VxnÙ`şã:Ú™Šú€ò|âq<ú1şKçü”ÇŒiãk /ó·Ò0æÀ4˜ ½á>(gÂNß¯ŸÄ•Şf¹,ul¶8Ç¾plvÙG.›ñÛ%8ÿFÎ=.å0‡rĞ‡ü½¬àïåym} 4ƒÛà
8ğ…#BŸƒ`(†‚ğwçÚÇEcŸwç\ç\ÒÖåû‹”+Î—Iœ¯]^Ã¡ÔÃ#âï‡øü]ø*ğ¾#t€†PŠÂAş¶>†şœë{ß(7¦ó{~?Æ>SÌLç˜êfAæ™•ÍÉl»8ÿôT>bÿ÷ŒıYçyqö9_¯Bìß
OAhd³‹®³~œ`æQq†=´V|Ûo@¶ß«^¢(<šãšIæÒMÎ1Åä@Ÿìög<Öãp¼Å·3¶±ğƒë¨œÁßŠ@Q¨—@I¸ã\¢°Òıìw8€»¢Ğ7GÚáİTMrl¦Û)‰Ñ×ıêTO;™í?ßÔ¶Í×]9?Îg¿uä1ƒù~x
‡6œ«#t±ÏO8|ÕÙïãœSœÔŞ„QÑx{©·Æğ‰ãs¢:Öv¯;3ÖüĞq¯Â¡;dœ;uølÜQæ”~~Vú´{ìó‰¶CIö²=”{ƒå™qMtœ&¤jgNªf¶¤SÑì'ÙÚàÙ&yù§zuv¸‡m…ûYÅf;áÇHn½R.Sõò®ã"©®Åc±]Ö¯µ=ÉX¾e\#¡94…~p—>#ËàáQÇ>şá( —–Êkrá¬(8vpİèyĞK~íéœSLr¢0‡NvİLv\æ»NNv»ÆÿÎ$ÊÀ¯üÿ–úß•?õs‘Ùáß¢ôÌg5Œ†gàş(Ü«®Àg8¬™úo+Ç¤‹s,Ùÿg*Ï’^'§±ÎµÄgÖ/ğøuë á	¸ÚèyO}h-F‡+ÌàYÖà00;8Ô†¿ÂcÎ«)®Åé)×^Û¥ê¨yÑ=`¨]’¾¦µçÜ_Xó;Ærn(¿ƒBğÃæ;8»ásX¹¸Œğ³ı†jœë/Q˜÷ÄÆÿ	ì†{£¯&®ùèÙV{»ôğk_÷ƒ¤'r?øğzÔ–•UsÚÏ?ï6€ç -´wøo3ı¼¤*çºş5aãÿØ5"‡ÆQxNğHÖ*ODá>¯ƒÔ³_p/HÖZŒplNv«ËøO.uàfxk*kÒ)Äš³_ñ(Éö_¯ZTXxœ“WCÂ@„HSDE:‚JÓ€64Øÿÿ‹{ï½ b[îÒ®äˆ˜çùvf6·ñx"‘L¦Rétz``pç3™lvhhx8—Ëçó…ÂÈÈèèØØøøÄD±8995%‘HOO4‹Åz{ûúúûãÆ€>JêS´>§Êª$©’Ç¢±ä\¬©”¾¨ôPÂ$H›,ËF©€tÑ¹€`ú©Ø-A–eğÔO(•JÓÓ33³³ssúC	5CõüüÂ# =¥ô|±şÙƒÚ}£¬u²‹üáéa†BÉøu	ñß·ep:wnúCa™!‘:1õdÂM™€Wïñtw{½>Ÿßï‚ÁPH¡{8<ïîèèììêòh¤¤Öåjow³±Ùí‡ÓÙÚÚÖæÂa‰õÑaÍf‹¥¥ÅjµÙì(,±¬°Ç™L&sFÍzCm4!j*’X‡S>)›Å8[ıóóëëûûG«[ƒ„2ŒaÇ¬Õ!Õf2!—JAV	½××0½›Şo ˆ¦·’õóÃ!^Z—T½«+¦AzÏ¯ooïïz @MôŸŸ_^ªÕWEX€Ò?È		=€ıœÅ\P«HëT.z‡ÇÇJDS­ĞhÙë››ÛÛ»»ûûÈVĞ^[#¬OÏÎÎÏ/../¯®®EÃ%š´Şß?88<<::>>99qŒWp„¯V7667·¶¶·wvvw÷ö  <1 \.¯­­¯k Jj |iiyyeeu1K	D,(ü›zxœí’;À0B¹cúO}ÿkT(UÒ•‘ŞşXˆ›Tr‘“d'YÉBJ	6lØ°Ñ g«†½2-ÿq+=½Õ+ê;zf²ëâ‹1\½UórşÕã»¢D–xœmXH›çVDœ„]6$½ˆ‘"ŞŞ\¯x]W[f;¯sÖºTSiÔøSšZ6µ5‰1ÚøÓØã_Œ1ş;—Ú4­.Û®B)E†„R¤ˆĞ"”†H)ŞûìğŞØmy1IË÷½Ïûœç<çœ/ÎaÏ¨kDn4ËÃó:«š#ÚZLÖAËo/ã€Ál±°ïÆz7X­ƒ!ë k÷¶˜^ŞeáŞìî¸ùcß§{NßOvÇê=£·kãÎaç°k$åæ¢":ä
WÃÕÈÀÀ.Ø“ıÑ²üÿE®Ü½ÓôôlFÑNOk ÆÉ{YâæfŸ}yÌkÅ5X)7{/Gç×\
nhSôÌ8©ÿü³ÁŒw`¾sØ1äÂşÎaEß³ë¡"iÉº2¢Í`>öıqW²[²pânšÁb±WKKnÁ3šÙµ®ŒwV½nä¨ËnùOİ	ñ ;p$Ï¨sØbyİøV¨,ßl ÆÉ{GçNŞ=<îŠi×õï4!‚Àpew»k#ÅÚÊ=UD›ÜH§¥“F€àÄ‰vzYUFqóÄ#İ“Ğa04ó´I8cHÜ³TÇ—0~?¨â;8à>ÒÜ`n}••Q´§ŠÒ‰{’İP£üÙ¢Üè³CuÊçpf—ªâİyUô(ìÅn~tıÆ]?Sƒâ„Å0äFğH”¾nŒii?y/nşŠWô°ñ§ÂŞå1×î¡ë
{×•áy½—Á#»ˆ	°tıX-¦PéIubcŒhËM-\T4ö¸7Ÿõ@ôğä=h^vK×_v§ñZÓKuñKKÁ£ìòÒ:H'üµ˜èï¤C1p5/Î…ç=¹«/ìıè»ã®¬õ?¾_Ø«ès×Î\åi™VêCEÚÊ—78jqù€é}YéúÉ/,b`a0ó´‘âèü'×¸šÓq4×ÿ'İÃÕ4Üæi[LŠ>`xFÅ=+õa¹5—à£4P‘Ö”aÌ!ä@ÆÂ1dØiâKÂó]ç¨:ÎÅÍËªÿqmşC´ÁÂ9,7>¹Í7kˆaâÃïqòŞ¡ÌA³´$<o©ç;:—ì–-v/¥{ÎíÏ,Áë¸ÍG.e{*6å&cAJÅÁªíOñÚS	
‚r]nÍîŞ˜€æå?@õcßx'Ğè†gT×¿Ù =^7F´¥ƒ”Pô5Ün¸¥5†åçáŞ˜ˆh{w>Td¯æi³»?¼ƒ¬’,HNß?yïÄİÙ@'ò
|İ–›[¼ÓÑ–ÙEş ¬ØP^‘g˜"äCë`L»  ,w]ÉQ'uîÏÈË,d=8}?n>nşè\È,óÇfC¤XZ²ÓÜ*î!o°|Uô1æD–»Ì…	Ò’ø‹3W¹šX=2WôP¶xå£ïv§ÉçºşàÖH1ò*¢-å&"NÎÃæCŠS„PC\MgUP0bÚ7&©Ó÷ÑCNÜ=î‚òÈ\Ï¨Ü¸§
Ë•–¼¼ÁÓŠ{PÛIZï÷çÕ:tŸÒÒPQÍ¥=UL{È¬èaº'ëA²Ç]ŞÙŸË=£Š¾àÖ°ÜÒRhÎòŠ¹ñaLàAŠùyïè|³ü 9¡Ãg¿âÂÑ¹¤Îµñ¾™E¬€¡ë?hæK€ÁÕdvÑYÉ×¤=a bQî:œY)V–£:EOß?:·6.22ûfÊù[?×õó´G.(ËQïÁƒ¼ÁêSƒ4'R÷Z,<íÈ•P‘ª‚£hóÙe‹ÈÙ	¹qË±;½;½1A™¡èã¨‘WÏ®ï©2»Ÿ\A{7ÜFn1°nO¹>Ùİs5A9ÈÊXıö$´ŞŸY·úìà`p#V-&6<¯ªl§	±%âp¸£S¤kÖ^ıî|Í¥g×cõ®‘@çîôª'_µùìK‹É3ŠÊe0ï©Âó„2Ô]ê¬Ò2%Xõ=<ıĞÄáJê´Wå¤®+£tŠ¾UÛÚ8º}:‡fÂ°î©â/V•¡G‘~Õ™»é“²Š¼VZI+õïÎc2ÙS¥pnìï³ûìkãQÇ0¼V]ÿË‚Aú~R'•íÎ–®ŸUch÷‰İi¯Õ1ÓŞYõ*+ş"ª	ê¦@¯ucbË±1Ft’Sp+_"-yr<È”W‰bEUZÛÜ™…¶Q:tjT;òêsØg§¬òZş÷r‚[…2\ÅÕ$u²YmgXÀ ŒõÙÁ!dv{Ò3jPô-Õ½;_U¶T·Ó„>%7"¦ˆ×ö¤Ï¾jCöá::QZZúì:W®ÌqşşwÄ‰²Û“û3NŸµd¥/©*s×  files = {};
        files[convert_path(name)] = read_file(name);
        output = name;
        run();
    });
} else if (paths.length) {
    simple_glob(paths).forEach(function(name) {
        files[convert_path(name)] = read_file(name);
    });
    run();
} else {
    var timerId = process.stdin.isTTY && process.argv.length < 3 && setTimeout(function() {
        print_error("Waiting for input... (use `--help` to print usage information)");
    }, 1500);
    var chunks = [];
    process.stdin.setEncoding("utf8");
    process.stdin.once("data", function() {
        clearTimeout(timerId);
    }).on("data", function(chunk) {
        chunks.push(chunk);
    }).on("end", function() {
        files = { STDIN: chunks.join("") };
        run();
    });
    process.stdin.resume();
}

function convert_ast(fn) {
    return UglifyJS.AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));
}

function run() {
    var content = options.sourceMap && options.sourceMap.content;
    if (content && content != "inline") {
        UglifyJS.AST_Node.info("Using input source map: {content}", {
            content : content,
        });
        options.sourceMap.content = read_file(content, content);
    }
    try {
        if (options.parse) {
            if (options.parse.acorn) {
                var annotations = Object.create(null);
                files = convert_ast(function(toplevel, name) {
                    var content = files[name];
                    var list = annotations[name] = [];
                    var prev = -1;
                    return require("acorn").parse(content, {
                        allowHashBang: true,
                        ecmaVersion: "latest",
                        locations: true,
                        onComment: function(block, text, start, end) {
                            var match = /[@#]__PURE__/.exec(text);
                            if (!match) {
                                if (start != prev) return;
                                match = [ list[prev] ];
                            }
                            while (/\s/.test(content[end])) end++;
                            list[end] = match[0];
                            prev = end;
                        },
                        preserveParens: true,
                        program: toplevel,
                        sourceFile: name,
                        sourceType: "module",
                    });
                });
                files.walk(new UglifyJS.TreeWalker(function(node) {
                    if (!(node instanceof UglifyJS.AST_Call)) return;
                    var list = annotations[node.start.file];
                    var pure = list[node.start.pos];
                    if (!pure) {
                        var tokens = node.start.parens;
                        if (tokens) for (var i = 0; !pure && i < tokens.length; i++) {
                            pure = list[tokens[i].pos];
                        }
                    }
                    if (pure) node.pure = pure;
                }));
            } else if (options.parse.spidermonkey) {
                files = convert_ast(function(toplevel, name) {
                    var obj = JSON.parse(files[name]);
                    if (!toplevel) return obj;
                    toplevel.body = toplevel.body.concat(obj.body);
                    return toplevel;
                });
            }
        }
    } catch (ex) {
        fatal(ex);
    }
    var result;
    if (specified["reduce-test"]) {
        // load on demand - assumes cloned repository
        var reduce_test = require("../test/reduce");
        if (Object.keys(files).length != 1) fatal("can only test on a single file");
        result = reduce_test(files[Object.keys(files)[0]], options, {
            log: print_error,
            verbose: true,
        });
    } else {
        result = UglifyJS.minify(files, options);
    }
    if (result.error) {
        var ex = result.error;
        if (ex.name == "SyntaxError") {
            print_error("Parse error at " + ex.filename + ":" + ex.line + "," + ex.col);
            var file = files[ex.filename];
            if (file) {
                var col = ex.col;
                var lines = file.split(/\r?\n/);
                var line = lines[ex.line - 1];
                if (!line && !col) {
                    line = lines[ex.line - 2];
                    col = line.length;
                }
                if (line) {
                    var limit = 70;
                    if (col > limit) {
                        line = line.slice(col - limit);
                        col = limit;
                    }
                    print_error(line.slice(0, 80));
                    print_error(line.slice(0, col).replace(/\S/g, " ") + "^");
                }
            }
        } else if (ex.defs) {
            print_error("Supported options:");
            print_error(format_object(ex.defs));
        }
        fatal(ex);
    } else if (output == "ast") {
        if (!options.compress && !options.mangle) {
            var toplevel = result.ast;
            if (!(toplevel instanceof UglifyJS.AST_Toplevel)) {
                if (!(toplevel instanceof UglifyJS.AST_Statement)) toplevel = new UglifyJS.AST_SimpleStatement({
                    body: toplevel,
                });
                toplevel = new UglifyJS.AST_Toplevel({
                    body: [ toplevel ],
                });
            }
            toplevel.figure_out_scope({});
        }
        print(JSON.stringify(result.ast, function(key, value) {
            if (value) switch (key) {
              case "enclosed":
                return value.length ? value.map(symdef) : undefined;
              case "functions":
              case "globals":
              case "variables":
                return value.size() ? value.map(symdef) : undefined;
              case "thedef":
                return symdef(value);
            }
            if (skip_property(key, value)) return;
            if (value instanceof UglifyJS.AST_Token) return;
            if (value instanceof UglifyJS.Dictionary) return;
            if (value instanceof UglifyJS.AST_Node) {
                var result = {
                    _class: "AST_" + value.TYPE
                };
                value.CTOR.PROPS.forEach(function(prop) {
                    result[prop] = value[prop];
                });
                return result;
            }
            return value;
        }, 2));
    } else if (output == "spidermonkey") {
        print(JSON.stringify(result.ast.to_mozilla_ast(), null, 2));
    } else if (output) {
        var code;
        if (result.ast) {
            var opts = {};
            for (var name in options.output) {
                if (!/^ast|code$/.test(name)) opts[name] = options.output[name];
            }
            code = UglifyJS.AST_Node.from_mozilla_ast(result.ast.to_mozilla_ast()).print_to_string(opts);
        } else {
            code = result.code;
        }
        fs.writeFileSync(output, code);
        if (result.map) fs.writeFileSync(output + ".map", result.map);
    } else {
        print(result.code);
    }
    if (nameCache) fs.writeFileSync(nameCache, JSON.stringify(options.nameCache));
    if (result.timings) for (var phase in result.timings) {
        print_error("- " + phase + ": " + result.timings[phase].toFixed(3) + "s");
    }
}

function fatal(message) {
    if (message instanceof Error) {
        message = message.stack.replace(/^\S*?Error:/, "ERROR:")
    } else {
        message = "ERROR: " + message;
    }
    print_error(message);
    process.exit(1);
}

// A file glob function that only supports "*" and "?" wildcards in the basename.
// Example: "foo/bar/*baz??.*.js"
// Argument `glob` may be a string or an array of strings.
// Returns an array of strings. Garbage in, garbage out.
function simple_glob(glob) {
    if (Array.isArray(glob)) {
        return [].concat.apply([], glob.map(simple_glob));
    }
    if (glob.match(/\*|\?/)) {
        var dir = path.dirname(glob);
        try {
            var entries = fs.readdirSync(dir);
        } catch (ex) {}
        if (entries) {
            var pattern = "^" + path.basename(glob)
                .replace(/[.+^$[\]\\(){}]/g, "\\$&")
                .replace(/\*/g, "[^/\\\\]*")
                .replace(/\?/g, "[^/\\\\]") + "$";
            var mod = process.platform === "win32" ? "i" : "";
            var rx = new RegExp(pattern, mod);
            var results = entries.sort().filter(function(name) {
                return rx.test(name);
            }).map(function(name) {
                return path.join(dir, name);
            });
            if (results.length) return results;
        }
    }
    return [ glob ];
}

function read_file(path, default_value) {
    try {
        return fs.readFileSync(path, "utf8");
    } catch (ex) {
        if (ex.code == "ENOENT" && default_value != null) return default_value;
        fatal(ex);
    }
}

function parse_js(value, options, flag) {
    if (!options || typeof options != "object") options = Object.create(null);
    if (typeof value == "string") try {
        UglifyJS.parse(value, {
            expression: true
        }).walk(new UglifyJS.TreeWalker(function(node) {
            if (node instanceof UglifyJS.AST_Assign) {
                var name = node.left.print_to_string();
                var value = node.right;
                if (flag) {
                    options[name] = value;
                } else if (value instanceof UglifyJS.AST_Array) {
                    options[name] = value.elements.map(to_string);
                } else {
                    options[name] = to_string(value);
                }
                return true;
            }
            if (node instanceof UglifyJS.AST_Symbol || node instanceof UglifyJS.AST_PropAccess) {
                var name = node.print_to_string();
                options[name] = true;
                return true;
            }
            if (!(node instanceof UglifyJS.AST_Sequence)) throw node;

            function to_string(value) {
                return value instanceof UglifyJS.AST_Constant ? value.value : value.print_to_string({
                    quote_keys: true
                });
            }
        }));
    } catch (ex) {
        if (flag) {
            fatal("cannot parse arguments for '" + flag + "': " + value);
        } else {
            options[value] = null;
        }
    }
    return options;
}

function skip_property(key, value) {
    return skip_keys.indexOf(key) >= 0
        // only skip truthy_keys if their value is falsy
        || truthy_keys.indexOf(key) >= 0 && !value;
}

function symdef(def) {
    var ret = (1e6 + def.id) + " " + def.name;
    if (def.mangled_name) ret += " " + def.mangled_name;
    return ret;
}

function format_object(obj) {
    var lines = [];
    var padding = "";
    Object.keys(obj).map(function(name) {
        if (padding.length < name.length) padding = Array(name.length + 1).join(" ");
        return [ name, JSON.stringify(obj[name]) ];
    }).forEach(function(tokens) {
        lines.push("  " + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
    });
    return lines.join("\n");
}

function print_error(msg) {
    process.stderr.write(msg);
    process.stderr.write("\n");
}

function print(txt) {
    process.stdout.write(txt);
    process.stdout.write("\n");
}
